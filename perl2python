#!/usr/bin/perl

#CURRENTLY WORKING ON LINE 104: test 3 is printing out print functions
#with newlines in the quotations that shouldn't be there
#also, it should be writing "sys.stdout.write(wordds...)" rather than
#print(wordds..), but the answers want print(wordds..) so have a look
#into this

#need to have some way to determine whether a variable is a string or a integer 
#maybe a dict of all variable names and just assume they are strings?

# written by andrewt@cse.unsw.edu.au September 2013
# as a starting point for COMP2041/9041 assignment 
# http://cgi.cse.unsw.edu.au/~cs2041/13s2/assignments/perl2python
# edited by hwav057@cse.unsw.edu.au for more functionality September 2013
$tab = 0;
our @python_source = ();
our @imports_python_source = ();
our %variables = [];
$lines_python_source = 0;
our $lines_imports = 0;
while ($line = <>) {
	#conditions TO-DO:
	# 2. foreach loops DONE //kinda.. needs more functionality
	# 3. needs a function that can check for SYS modules, ie ARGV etc.. maybe reads in a line, and returns a line which has had the appropriate changes?
	# 5. boolean logic and string concatenation
	# 6. range operator and when perl converts array to scalar length (context)
	chomp $line;
	if ($line =~ /^#!/ && $. == 1) {
	
		# translate #! line 
		
		print "#!/usr/bin/python2.7 -u\n";
	} elsif ($line =~ /^\s*#/ || $line =~ /^\s*$/) {
	
		# Blank & comment lines can be passed unchanged
		addToSourceArray("$line\n");
	} elsif ($line =~ /^\s*print\s*("*.*\s*\\n\s*")*\s*\;*$/) {
		# Python's print adds a new-line character by default
		# so we need to delete it from the Perl print statement
		#TO-DO: need to consider case of variablie interpolation
		#still not done, can only work when only printing variable
		$temp = $1;
		printFunction($temp);
			
	} elsif ($line =~ /^\s*\$(.+)\;$/) {
		#declaring a variable 
		#python just removes the dollar sign and semi-colon
		($a,$temp) = split /\s*\=\s*/, $1;	
		variableDec($a,$temp);	
 	} elsif ($line =~ /^\s*if\s*\((.*)\)\s*\{\s*$/) {
		#if condition
		#NOT COMPLETE
		#needs variable interp
		handleIf($1);
		$tab++;
	} elsif ($line =~ /^\s*while\s*\((.*)\)\s*\{\s*$/) {
		#while loop
		handleWhile($1);
		$tab++;
	} elsif ($line =~ /^\s*foreach\s*(.+)\)\s*\{\s*$/) {
		#foreach loop
		handleForeach($1);
		$tab++;
	} elsif ($line =~ /^\s*\}\s*.*\s*$/) {
		#catch the end of a loop or similar statement with a "}"
		#WON'T work if there is anything else in the line, ie a elsif stat
		$tab--;
		$result = handleElse($line); # =1 when else, =0 when normal
		$tab += $result;
	} elsif ($line =~ /^\s*chomp \$([^\;]*)\;\s*$/) {
		#handle chomp function	
		addToSourceArray("$1 = $1.rstrip()\n");
	} elsif ($line =~ /\s*last;\s*$/) {
		addToSourceArray("break\n");
	} else {
	
		# Lines we can't translate are turned into comments
		
		addToSourceArray("#$line\n");
	}
	$lines_python_source++;
}
outputSource();

sub variableDict {
	my $line_to_check = $_[0];
	foreach $word (split /\s+/, $line_to_check) {
		
	}
}

sub variableDec {
	my $variable_name = $_[0];
	my $variable_assign = $_[1];
	if ($variable_assign =~ /\$/) {
			#check if each item is a variable and interp
			@assigns = split / /, $variable_assign;
			$line_to_print = "$variable_name = ";
			foreach $assignment (@assigns) {
				if ($assignment eq "\<STDIN\>") {
					handleImports("sys");
					$assignment = "sys.stdin.readline()";
				} elsif ($assignment =~ /\$/) {
					$assignment =~ s/\$//;
				}	
				$line_to_print .= "$assignment ";
			}
			$line_to_print .= "\n";
			addToSourceArray($line_to_print);
		} else { #ERRRRORORORORORORORORORORORORO CHANGE TO CHECKSYSMOD
			#if ($variable_assign eq "\<STDIN\>") {
			#	handleImports("sys");
			#	$variable_assign = "sys.stdin.readline()";
			#}
			$variable_assign = checkSysMod($variable_assign);
			addToSourceArray("$variable_name = $variable_assign\n");
		}
}

sub checkSysMod {
	my $to_check = $_[0];
	#if ('@ARGV' eq '@ARGV') { print "HIIIII\n"; }
	#check if any sys commands are present
	if ($to_check eq '@ARGV') {
		$to_check = 'sys.argv[1:]';
		handleImports('sys');
	} elsif ($to_check eq '<STDIN>') {
		$to_check = "sys.stdin.readline()";
		handleImports('sys');
	}

	#replace them with python equiv
	#call handle imports if true	
	return $to_check;
}

sub printFunction {
	my $to_check = $_[0];
	#if (($to_check =~ /\$/)||($to_check =~ /^\s*\"([^\"]*)\"\s*$/)) {
		#case of more complicated print statements including variables and functions etc..
		#note: currently only handles functions that are declared using brackets
		#if declared without brackets, then will be commented
		#cant handle multiple strings
		
		$to_check =~ s/\"//g; #remove trailing ""
		
		@statements = split / *\, *| +/, $to_check;
		
		$line_to_print = "print ";
		my $is_string = 0;
		my $dont_add_space = 0;
		$last_stat = $statements[$#statements];
		
		$last_stat =~ s/\\n//g;
		while ($stat = shift @statements) {
			$stat =~ s/\\n//g;
			if ($stat =~ /^\s*\$(.*)$/) {
				if ($is_string == 1) {
					$line_to_print .= "\"\,";
					$is_string = 0;
				} 
				$line_to_print .= "$1";
			} elsif ($stat eq "\*") {
				if ($is_string == 1) {
					$line_to_print .= "\" ";
					$is_string = 0;
				} 
				$line_to_print .= "$stat";
			} elsif ($stat eq "") {
				#this is the case that the string to print was just a newline
				#just going to assume its nothing
				$dont_add_space = 1;
			
			} elsif ($stat =~ /^\s*join\((.*)/) {	
			#case it is a function call
			#this is a difficult one as the spilt statement on line 140 can be faulty here
			#as arguments in function calls are separated by commas
			#so in this case, i need to get all the arguments and then process the line
				$stat = $1;
				if ($stat eq '\'') {
					#we need the next bit
					$stat2 = shift @statements;
					if ($stat2 eq '\'') {
						#they were trying to seperate it with whitespace
						$line_to_print .= "\' \'.join\(";
					} else {
						#seperating it with something else
						$stat2 =~ s/\'//;
						$line_to_print .= "\'$stat2\'.join\(";
					}
					#no to find the variable they are joining
					$stat = shift @statements;
					$stat =~ s/\)//;
					#print "i am checking 
					$stat = checkSysMod($stat);
					$line_to_print .= $stat.")";
				}
				
			} else {
			#case printing a string, need to add quotes
				$line_to_print .= "\"$stat" if $is_string == 0;
				$line_to_print .= "$stat" if $is_string == 1;
				$is_string = 1;
			}
			#add space if its not last expression in print statement
			if (($stat ne $last_stat)&&($dont_add_space == 0)) {
				$line_to_print .= " ";
			}
			$dont_add_space = 0;
		}
		#$line_to_print .= ")" if $sys_check == 1;
		$line_to_print .= "\"" if $is_string == 1;
		$line_to_print .= "\n";
		addToSourceArray($line_to_print);
	#}  {
		#case printing just a string, got to remove "\n"
		#if (grep( /^$import_to_check$/, @imports_python_source)) {
		#	addToSourceArray("sys.stdout.write\(\"$to_check\"\)\n");
		#} else {
		#$to_check = $1;
		#$to_check =~ s/\\n//g;
	#	addToSourceArray("print \"$to_check\"\n");
		#}
		
	
}

sub conditionHandling {
	#function to go through conditional statements and to translate them 
	#appropriately to python and returns the result
	my $cond_to_check = $_[0];
	
	if ($cond_to_check =~ /^\$(.*)$/) {
		#variable declaration, just remove "$"
		return $1;
	} elsif ($cond_to_check =~ /^\>=*|[=!]=|\<=*|%$/) {
		#conditional operators that are the same in perl and python
		return " $cond_to_check ";
	} elsif ($cond_to_check eq "ne") {
		return " != ";
	} elsif ($cond_to_check eq "eq") {
		return " == ";
	} elsif ($cond_to_check eq "lt") {
		return " < ";
	} elsif ($cond_to_check eq "gt") {
		return " > ";
	} elsif ($cond_to_check eq "le") {
		return " <= ";
	} elsif ($cond_to_check eq "ge") {
		return " >= "
	} elsif ($cond_to_check =~ /^[\"\'0-9a-zA-Z]+$/) {
		return $cond_to_check;
	} else { return "?$cond_to_check?"; } 
}

sub handleIf {
	#function for handling if statements, mainly just changes curly brackets
	#to colon, and translates the condition statement
	my $conds_to_trans = $_[0];
	$line_to_print = "if ";

	#now loop through conds and trans
	my @conds = split /\s+/, $conds_to_trans;
	
	foreach $cond (@conds) {
		$line_to_print .= conditionHandling($cond);
	}
	
	addToSourceArray("$line_to_print:\n");
}

sub handleWhile {
	my $conds_to_trans = $_[0];
	$line_to_print = "while ";

	my @conds = split /\s+/, $conds_to_trans;

	foreach $cond(@conds) {
		$line_to_print .= conditionHandling($cond);
	}

	addToSourceArray("$line_to_print:\n");
}

sub handleImports {
	my $import_to_check = $_[0];
	if (!grep( /^$import_to_check$/, @imports_python_source)) {
		$imports_python_source[$lines_imports] = "$import_to_check";
		$lines_imports++;
	} 
	#now the previous lines in our source output array need to be altered
	#to fit with the new import (ie the print funct is now 
	#sys.stdout.write()
	#JUST WRITING ONE TO CHECK FOR PRINT FUNCTION IN SYS NOW	
	#foreach $line (@python_source) {
	#	if ($line =~ /^(\s*)print\s*(.*)$/) {
	#		$line = "$1sys.stdout.write($2)\n";
	#	} 
	#}
}

sub handleForeach {
	#foreach loops are slightly tougher than if and while loops to translate
	#they use a declaration and then a set of numbers which act as a range 
	#of indexes
	my $conds_to_trans = $_[0];
        $line_to_print = "for ";

        my @conds = split /\s+/, $conds_to_trans;

	#first variable will just be a variable name
	$line_to_print .= conditionHandling($conds[0]);

	#then need to add some python syntax
	$line_to_print .= " in ";

	#then the difficult part, translating range
	#ATM just considering basic example of (x..y)
	
	$conds[1] =~ s/\(|\)//;
	my @nums = split /\.+/, $conds[1];
	$nums[0] = checkSysMod($nums[0]);
	if ($nums[0] eq 'sys.argv[1:]') {
		$line_to_print .= $nums[0];
	} else {
		$line_to_print .= "range(";
		$nums[1] = checkSysMod($nums[1]);
		$nums[1]++; #pythons range function doesn't include last num
		$line_to_print .= "$nums[0], $nums[1])";
	}
    addToSourceArray("$line_to_print:\n");
	
}

sub handleElse {
	my $cond_to_handle = $_[0];
	#print "Hayden here and ($cond_to_handle)\n";
	if ($cond_to_handle =~ /^\s*\}\s*elsif\s*\((.*)\)\s*\{\s*$/) {
		#case that it is an elsif statement
		$line_to_print = "elif ";
 
	         #now loop through conds and trans
        	my @conds = split /\s+/, $1;
 	
        	foreach $cond (@conds) {
                	$line_to_print .= conditionHandling($cond);
        	}	

        	addToSourceArray("$line_to_print:\n");
		return 1;
	} elsif ($cond_to_handle =~ /^\s*\}\s*else\s*\{\s*$/) {
		#case that it is a normal else statement
		addToSourceArray("else:\n");
		return 1;
	} else {
		return 0; #case its the end
	}

	return $result;
}

sub addToSourceArray {
	my $to_print = $_[0];
	$amt_tabs = $tab;
	while ($amt_tabs > 0) {
		$python_source[$lines_python_source] .= "    ";
		$amt_tabs--;
	}
	$python_source[$lines_python_source] .= $to_print;
}

sub outputSource {
	print "import " if $lines_imports != 0;
	$i = 0;
	foreach $line (@imports_python_source) {
		print $line;
		if ($i < $lines_imports - 1) { print ", "; }
		$i++	
	}
	print "\n" if $i != 0;
	foreach $line (@python_source) {
		print $line;
	}
}
